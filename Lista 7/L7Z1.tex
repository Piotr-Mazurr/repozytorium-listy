\documentclass{article}
\author{Piotr Mazur}
% użyte pakiety
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{listings}
\lstset{frame=single}
\usepackage{caption}
\usepackage{graphicx}
\usepackage{float}
%\usepackage{amsthm}

%odstępy pionowe
%odstęp w podsekcjach: \bigskip
%odstęp w sekcjach (pomiędzy podsekcjami): \bigskip\bigskip

\title{Rozwiązania wybranych zadań z list}

\begin{document}
\maketitle
\tableofcontents

\newpage
\section{lista 5, zadanie 2}
\noindent \textbf{Treść zadania:} Napisz funkcjc \verb|bright _pixel(image)| , ktora dla trójwymiarowej tablicy \verb|image| reprezentującej kolorowy obraz (w sposób opisany na wykładzie) sprawdza, czy w jego lewej górnej ćwiartce znajduje się co najmniej jeden piksel, dla którego co najmniej jedna ze składowych RGB ma wartość większą, niż 200. Cwiartkę tę rozumiemy jako obrazek powstaly z pierwszej połowy wierszy i pierwszej połowy kolumn danego obrazu (odpowiednio zaokrqglajqc liczbę wierszy lub kolumn w dół). Funkcja powinna zwracać \verb|True|, jeżeli taki piksel istnieje i \verb|False| w przeciwnym wypadku. 

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{cat.jpg}
    \captionsetup{labelformat=empty}
    \caption{rozpatrywany obraz}
\end{figure}

\bigskip\bigskip

\subsection{Krok 1}
\label{l5z2_krok:1}
\noindent importowanie potrzebnych bibliotek, tj.:
\begin{enumerate}
    \item \verb|imageio| do zaimportowania obrazu jako trójwymiarowej tablicy pikseli.
    \item \verb|matplotlib.pyplot| do wyświetlenia zaimportowanego obrazu.
    \item \verb|numpy| do działań na tablicy obrazu i przechowywania informacji o tej tablicy.
\end{enumerate}

\begin{lstlisting}
import imageio
import matplotlib.pyplot as plt
import numpy as np
\end{lstlisting}

\bigskip\bigskip

\subsection{Krok 2}
\label{l5z2_krok:2}
\noindent zdefiniowanie obrazka (gdzie ,, ... '' symbolizuje link do obrazka lub ścieżkę na dysku). \verb|print(image.shape| jako pomocnicze wyświetlenie wymiarów tablicy.
\begin{lstlisting}
image=imageio.v2.imread(...)
print(image.shape)

plt.imshow(image)
plt.show()
\end{lstlisting}

\bigskip\bigskip

\subsection{Krok 3}
\label{l5z2_krok:3}
\noindent zdefiniowanie wymiarów tablicy osobno:
\begin{enumerate}
    \item \verb|h| – ilość wierszy w tablicy (wysokość obrazu w pikselach)
    \item \verb|w| – ilość kolumn w tablicy (szerokość obrazu w pikselach)
    \item \verb|d| – ilość wymiarów tablicy (ilość kanałów obrazu. Standardowo: R,G,B)
\end{enumerate}

\begin{lstlisting}
h, w, d = image.shape
\end{lstlisting}

\bigskip\bigskip

\subsection{Krok 4}
\label{l5z2_krok:4}
\noindent Separacja konkretnej części tablicy, czyli wycięcie ćwiartki obrazu.
\begin{lstlisting}
quarter = image[0: int(h/2), 0: int(w/2), :]
\end{lstlisting}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{qcat.jpg}
    \captionsetup{labelformat=empty}
    \caption{ćwiartka obrazu}
\end{figure}

\bigskip\bigskip

\subsection{Krok 5}
\label{l5z2_krok:5}
\noindent Warunek sprawdzający czy którykolwiek element tablicy \verb|quarter| ma wartość numeryczną większą od 200.
\begin{lstlisting}
np.max(quarter) > 200
\end{lstlisting}

\bigskip\bigskip

\subsection{Krok 6}
\label{l5z2_krok:6}
\noindent Połączenie fragmentów kodu napisanych w punktach \ref{l5z2_krok:1}, \ref{l5z2_krok:2}, \ref{l5z2_krok:3}, \ref{l5z2_krok:4} \ref{l5z2_krok:5} w spójną całość:
\begin{lstlisting}
def bright_pixel(image):
    h, w, d = image.shape
    quarter = image[0: (h//2), 0: int(w/2), :]
    return np.max(quarter) > 200

print(bright_pixel(image))
\end{lstlisting}

\bigskip\bigskip\bigskip

\newpage
\section{lista 2, zadanie 2}
\textbf{Treść zadania:} Rozważmy prostokątną planszę o 10 wierszach i 10 kolumnach, której każde pole opisane jest przez parę współrzędnych: numer wiersza oraz numer kolumny (dwie liczby od 1 do 10). Napisz program, który dla liczb \(i, j\) (gdzie \(1\leqslant i,j\leqslant 10\)) wypisze wszystkie pola (tzn. ich współrzędne) sąsiadujące z polem w \(i\)-tym wierszu i \(j\)-tej kolumnie, oraz to pole. Pola sąsiadują ze sobą bokami oraz na ukos. Przykładowo, dla pola o współrzędnych \((1, 2)\) poprawny wynik to pola o współrzędnych \((1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3)\). Kolejność wypisywania pól może być dowolna, o ile zostaną wypisane odpowiednie pola.
\bigskip

\[
\begin{bmatrix}
d_{11} & d_{12} & d_{13} & d_{14} & d_{15} & d_{16} & d_{17} & d_{18} & d_{19} & d_{1,10} \\
d_{21} & d_{22} & d_{23} & d_{24} & d_{25} & d_{26} & d_{27} & d_{28} & d_{29} & d_{2,10} \\
d_{31} & d_{32} & d_{33} & d_{34} & d_{35} & d_{36} & d_{37} & d_{38} & d_{39} & d_{3,10} \\
d_{41} & d_{42} & d_{43} & d_{44} & d_{45} & d_{46} & d_{47} & d_{48} & d_{49} & d_{4,10} \\
d_{51} & d_{52} & d_{53} & d_{54} & d_{55} & d_{56} & d_{57} & d_{58} & d_{59} & d_{5,10} \\
d_{61} & d_{62} & d_{63} & d_{64} & d_{65} & d_{66} & d_{67} & d_{68} & d_{69} & d_{6,10} \\
d_{71} & d_{72} & d_{73} & d_{74} & d_{75} & d_{76} & d_{77} & d_{78} & d_{79} & d_{7,10} \\
d_{81} & d_{82} & d_{83} & d_{84} & d_{85} & d_{86} & d_{87} & d_{88} & d_{89} & d_{8,10} \\
d_{91} & d_{92} & d_{93} & d_{94} & d_{95} & d_{96} & d_{97} & d_{98} & d_{99} & d_{9,10} \\
d_{10,1} & d_{10,2} & d_{10,3} & d_{10,4} & d_{10,5} & d_{10,6} & d_{10,7} & d_{10,8} & d_{10,9} & d_{10,10} \\
\end{bmatrix}
\]
\begin{center}
    Opisana plansza, przedstawiona jako macierz:
\end{center}

\bigskip\bigskip


\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
 &  &  \\
\hline
\(d_{11}\) & \(d_{12}\) & \(d_{13}\) \\
\hline
\(d_{21}\) & \(d_{22}\) & \(d_{23}\) \\
\hline
\end{tabular}
\captionsetup{labelformat=empty}
\caption{sąsiedztwo elementu \(d_{12}\)}
\end{table}

\bigskip\bigskip

\subsection{Krok 1}
\label{l2z2_krok:1}
\noindent Pobranie danych od użytkownika. Oczekujemy numeru \(i\) wiersza oraz numeru \(j\) kolumny rozpatrywanego elementu:

\begin{lstlisting}
i=int(input("i wiersz:"))
j=int(input("j kolumna:"))
\end{lstlisting}

\subsection{Krok 2}
\label{l2z2_krok:2}
\noindent Sprawdzenie sensowności wprowadzonych danych poprzez zdefiniowanie warunku logicznego.
\begin{lstlisting}
if 10 >= i >= 1 and 10 >= j >= 1:

else:
  print("Podano bledne dane")
\end{lstlisting}

\bigskip\bigskip

\subsection{Krok 3}
\label{l2z2_krok:3}
\noindent Zdefiniowanie listy wszystkich indeksów macierzy tj. \((1,1), (1,2), (1,3)\cdots \) Lista powinna zawierać 100 elementów.
\begin{lstlisting}
p=[(m,n) for m in range (1,10+1) for n in range(1,10+1)]
\end{lstlisting}

\bigskip\bigskip

\subsection{Krok 4}
\label{l2z2_krok:4}
\noindent
\begin{enumerate}
\item Zdefiniowanie pętli, która przebiegnie po wszystkich elementach z listy p. \label{item:1}
\item Zdefiniowanie warunku logicznego, który sprawi, że pętla wybierze te elementy \(d_{mn}\), których numer wiersza sąsiaduje z wprowadzonym numerem tj. \(m=i-1 \vee m=i+1\) \label{item:2}
\item Zdefiniowanie warunku logicznego, który sprawi, że pętla wybierze te elementy \(d_{mn}\), których numer kolumny sąsiaduje z wprowadzonym numerem tj. \(n=j-1 \vee n=j+1\) \label{item:3}
\item koniunkcja warunków logicznych z punktów \ref{item:2} i \ref{item:3} pozwoli wydrukować każdy element sąsiadujący z tym, który użytkownik wprowadził na początku.
\end{enumerate}
\begin{lstlisting}
for d in p:
    if (d[0] == i-1 or d[0] == i or d[0] == i+1) and
    (d[1] == j-1 or d[1] == j or d[1] == j+1):
        print(f"{p}")
\end{lstlisting}

\bigskip\bigskip

\subsection{Krok 5}
\label{l2z2_krok:5}
\noindent Połączenie fragmentów kodu napisanych w punktach \ref{l2z2_krok:1}, \ref{l2z2_krok:2}, \ref{l2z2_krok:3}, \ref{l2z2_krok:4} w spójną całość:

\begin{lstlisting}
i=int(input("i wiersz:"))
j=int(input("j kolumna:"))

if 10 >= i >= 1 and 10 >= j >= 1:
    p=[(m,n) for m in range (1,10+1) for n in range(1,10+1)]

    for d in p:
        if (d[0] == i-1 or d[0] == i or d[0] == i+1) and
        (d[1] == j-1 or d[1] == j or d[1] == j+1):
            print(f"{p}")
else:
  print("Podano bledne dane")
\end{lstlisting}


\end{document}


